<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>魔法轟炸網頁 - 完整效果（流星、尾跡、爆光、火焰、裂痕、當機）</title>
<style>
  html,body{height:100%;}
  body{margin:0; background:#0b0b10; overflow:hidden;}
  #gameCanvas{display:block}
  #hint{position:fixed;left:12px;top:12px;color:#fff;font-family:sans-serif;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;z-index:10}
  #crashOverlay{display:none;position:fixed;inset:0;background:rgba(10,0,0,0.95);z-index:9999;align-items:center;justify-content:center;color:#ffdddd;font-family:sans-serif}
  #crashOverlay h1{font-size:56px;color:#ff6666;text-shadow:0 0 12px #ff0000}
  #crashOverlay p{font-size:20px}
</style>
</head>
<body>
<div id="hint">點擊任意處發射流星魔法（流星：內藍外黃，尾巴：彗星尾+粒子）。</div>
<canvas id="gameCanvas"></canvas>
<div id="crashOverlay"><div style="text-align:center"><h1>系統當機</h1><p>魔法能量過載，動畫已停止。</p></div></div>
<script>
// -------------------- 設定 --------------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resize(){canvas.width = window.innerWidth; canvas.height = window.innerHeight}
window.addEventListener('resize', resize); resize();

// 資源（若沒有對應圖片，程式會 fallback 繪製）
const characterImg = new Image(); characterImg.src = 'character.png';
let characterLoaded = false; characterImg.onload = () => { characterLoaded = true; startIfNeeded(); };
characterImg.onerror = () => { characterLoaded = false; startIfNeeded(); };

const flameImg = new Image(); flameImg.src = 'flame.png'; let flameLoaded = false; flameImg.onload = () => flameLoaded = true; flameImg.onerror = () => flameLoaded = false;
const crackImg = new Image(); crackImg.src = 'crack.png'; let crackLoaded = false; crackImg.onload = () => crackLoaded = true; crackImg.onerror = () => crackLoaded = false;

if (characterImg.complete && characterImg.naturalWidth !== 0) characterLoaded = true;
if (flameImg.complete && flameImg.naturalWidth !== 0) flameLoaded = true;
if (crackImg.complete && crackImg.naturalWidth !== 0) crackLoaded = true;

// -------------------- 參數（依你說的角色頭約 50px） --------------------
const characterHeadPx = 50; // 你說的頭大小
const projectileRadius = Math.round(characterHeadPx * 0.95); // 流星與頭差不多大
const projectileTravelTime = 0.35; // 秒
const effectLimit = 25; // 過多顯示當機

// -------------------- 世界狀態 --------------------
let running = false;
let character = { x: canvas.width/2, y: canvas.height/2, size: characterHeadPx/2, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3 };

// 儲存所有飛行中的流星、爆光、火焰裂痕
let projectiles = []; // {x,y,tx,ty,t0,t1, vx,vy, rotation,...}
let explosions = []; // temporary blast animation
let groundEffects = []; // persistent fire+crack effects that may trigger crash

// 粒子池（尾巴粒子）
let particles = [];

// -------------------- 工具 --------------------
function now(){return performance.now()/1000}

function lerp(a,b,t){return a + (b-a)*t}

function startIfNeeded(){ if (!running){ running = true; requestAnimationFrame(loop); } }

// -------------------- 輪廓動作 --------------------
function moveCharacter(){
  character.x += character.vx; character.y += character.vy;
  if (character.x - character.size < 0 || character.x + character.size > canvas.width) character.vx *= -1;
  if (character.y - character.size < 0 || character.y + character.size > canvas.height) character.vy *= -1;
}

// -------------------- 點擊發射流星 --------------------
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const tx = e.clientX - rect.left; const ty = e.clientY - rect.top;
  spawnProjectile(character.x, character.y, tx, ty);
});

function spawnProjectile(sx, sy, tx, ty){
  const t0 = now();
  const t1 = t0 + projectileTravelTime;
  const angle = Math.atan2(ty - sy, tx - sx);
  projectiles.push({ sx, sy, tx, ty, x: sx, y: sy, t0, t1, angle, radius: projectileRadius, tailTimer:0 });
}

// -------------------- 畫流星（彗星球 + 粒子尾） --------------------
function drawProjectile(p, t){
  // 計算進度
  const progress = Math.min(1, (t - p.t0) / (p.t1 - p.t0));
  // 插值位置
  p.x = lerp(p.sx, p.tx, progress);
  p.y = lerp(p.sy, p.ty, progress);

  // 產生尾巴粒子（每幾幀）
  p.tailTimer += 1;
  if (p.tailTimer % 2 === 0){
    // 粒子有藍到黃的漸層色與生命
    particles.push({ x: p.x - Math.cos(p.angle)*p.radius*0.6, y: p.y - Math.sin(p.angle)*p.radius*0.6, vx: (Math.random()-0.5)*0.8, vy: (Math.random()-0.5)*0.8-0.2, life: 0.45 + Math.random()*0.3, size: Math.random()*6+2, hueShift: Math.random() });
  }

  // 彗星尾（流線漸層）
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.angle);
  // tail gradient
  const tailLen = 120 + 200 * (1-progress);
  const g = ctx.createLinearGradient(-tailLen, 0, 0,0);
  g.addColorStop(0, 'rgba(40,120,255,0)');
  g.addColorStop(0.35, 'rgba(80,160,255,0.15)');
  g.addColorStop(0.7, 'rgba(255,220,100,0.25)');
  g.addColorStop(1, 'rgba(255,240,180,0.9)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.ellipse(-tailLen/2, 0, tailLen, p.radius*0.9, 0, 0, Math.PI*2);
  ctx.fill();

  // 彗星核心（內藍外黃）
  const coreR = p.radius;
  const coreG = ctx.createRadialGradient(0,0, coreR*0.1, 0,0, coreR);
  coreG.addColorStop(0, 'rgba(160,220,255,1)');
  coreG.addColorStop(0.5, 'rgba(60,140,255,0.95)');
  coreG.addColorStop(0.85, 'rgba(255,210,100,0.6)');
  coreG.addColorStop(1, 'rgba(255,200,60,0.15)');
  ctx.fillStyle = coreG;
  ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2); ctx.fill();

  // 輪廓光暈
  ctx.globalAlpha = 0.6*(1-progress);
  ctx.beginPath(); ctx.arc(0,0, coreR*1.8,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // 如果到達目標，產生爆光
  if (progress >= 1){
    spawnExplosion(p.tx, p.ty);
    // 留下一個地面效果（火焰+裂痕）
    spawnGroundEffect(p.tx, p.ty);
    // 移除 projectile
    const idx = projectiles.indexOf(p); if (idx >=0) projectiles.splice(idx,1);
  }
}

// -------------------- 粒子更新與繪製 --------------------
function updateAndDrawParticles(dt){
  for (let i = particles.length -1; i>=0; i--){
    const pr = particles[i];
    pr.life -= dt;
    pr.x += pr.vx; pr.y += pr.vy;
    pr.vy -= 0.02; // slight upward drift
    if (pr.life <= 0) { particles.splice(i,1); continue; }
    // color shift blue -> yellow
    const t = Math.max(0, Math.min(1, 1 - pr.life));
    const r = Math.round(lerp(60,255,t));
    const g = Math.round(lerp(140,220,t));
    const b = Math.round(lerp(255,100,t));
    ctx.save(); ctx.globalAlpha = Math.min(1, pr.life*1.4); ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.beginPath(); ctx.arc(pr.x, pr.y, pr.size * Math.max(0.2, pr.life), 0, Math.PI*2); ctx.fill(); ctx.restore();
  }
}

// -------------------- 爆光（短暫動畫） --------------------
function spawnExplosion(x,y){
  explosions.push({ x,y, t: now(), duration: 0.35 });
}
function drawExplosions(t){
  for (let i = explosions.length -1; i>=0; i--){
    const ex = explosions[i];
    const dt = (t - ex.t)/ex.duration;
    if (dt >= 1){ explosions.splice(i,1); continue; }
    const ease = Math.sin(dt*Math.PI);
    const R = 10 + ease*80;
    // star-like flash (using radial gradients + stroke)
    ctx.save();
    ctx.globalAlpha = 1 - dt;
    const g = ctx.createRadialGradient(ex.x,ex.y,0, ex.x,ex.y, R*1.4);
    g.addColorStop(0,'rgba(255,255,220,0.95)'); g.addColorStop(0.4,'rgba(255,220,120,0.7)'); g.addColorStop(1,'rgba(255,120,40,0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(ex.x,ex.y,R,0,Math.PI*2); ctx.fill();
    // quick burst lines
    ctx.strokeStyle = `rgba(255,240,160,${0.9*(1-dt)})`; ctx.lineWidth = 2;
    for (let a=0;a<8;a++){ const ang = a*(Math.PI*2/8) + dt*2; ctx.beginPath(); ctx.moveTo(ex.x + Math.cos(ang)*R*0.4, ex.y + Math.sin(ang)*R*0.4); ctx.lineTo(ex.x + Math.cos(ang)*(R*1.2 + dt*40), ex.y + Math.sin(ang)*(R*1.2 + dt*40)); ctx.stroke(); }
    ctx.restore();
  }
}

// -------------------- 地面持續效果（火焰 + 裂痕） --------------------
function spawnGroundEffect(x,y){
  // size and rotation
  const s = 0.9 + Math.random()*0.8;
  groundEffects.push({ x,y, life: 1.0, scale: s, rotation: Math.random()*Math.PI*2 });
  if (groundEffects.length > effectLimit){ showCrashScreen(); }
}

function drawGroundEffects(dt){
  for (let i = groundEffects.length -1; i>=0; i--){
    const ge = groundEffects[i];
    ge.life -= dt*0.02; // very slow fade
    ge.scale += 0.002;
    if (ge.life <= 0){ groundEffects.splice(i,1); continue; }
    const baseSize = 110 * ge.scale;
    // draw crack at bottom
    if (crackLoaded){
      ctx.save(); ctx.globalAlpha = 0.9 * ge.life; ctx.translate(ge.x, ge.y); ctx.rotate(ge.rotation); ctx.drawImage(crackImg, -baseSize, -baseSize/1.6, baseSize*2, baseSize*1.2); ctx.restore();
    } else {
      ctx.save(); ctx.globalAlpha = 0.6 * ge.life; ctx.fillStyle = '#221'; ctx.beginPath(); ctx.ellipse(ge.x, ge.y, baseSize, baseSize*0.5, ge.rotation, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
    // draw flame above
    if (flameLoaded){
      ctx.save(); ctx.globalAlpha = 0.95 * ge.life; ctx.translate(ge.x, ge.y - baseSize*0.08); ctx.rotate(-ge.rotation*0.4); ctx.drawImage(flameImg, -baseSize*0.7, -baseSize*0.9, baseSize*1.4, baseSize*1.4); ctx.restore();
    } else {
      // radial flame gradient
      const g = ctx.createRadialGradient(ge.x, ge.y - baseSize*0.08, 10, ge.x, ge.y - baseSize*0.08, baseSize);
      g.addColorStop(0, `rgba(255,220,120,${0.95*ge.life})`);
      g.addColorStop(0.4, `rgba(255,120,30,${0.7*ge.life})`);
      g.addColorStop(1, `rgba(40,10,10,0)`);
      ctx.save(); ctx.globalAlpha = 1; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(ge.x, ge.y - baseSize*0.08, baseSize, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
  }
}

// -------------------- 當機 UI --------------------
function showCrashScreen(){ running = false; document.getElementById('crashOverlay').style.display = 'flex'; }

// -------------------- 繪製角色 --------------------
function drawCharacter(){
  if (characterLoaded){
    ctx.drawImage(characterImg, character.x - character.size, character.y - character.size, character.size*2, character.size*2);
  } else {
    ctx.save(); ctx.fillStyle = '#5fd0ff'; ctx.beginPath(); ctx.arc(character.x, character.y, character.size, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#32a0ff'; ctx.lineWidth = 3; ctx.stroke(); ctx.restore();
  }
}

// -------------------- 主迴圈 --------------------
let lastTime = now();
function loop(){
  if (!running) return;
  const t = now();
  const dt = Math.min(0.05, t - lastTime); // clamp
  lastTime = t;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  moveCharacter();
  drawCharacter();

  // projectiles
  for (let i = projectiles.length-1; i>=0; i--){ drawProjectile(projectiles[i], t); }

  // particles
  updateAndDrawParticles(dt);

  // explosions
  drawExplosions(t);

  // ground effects
  drawGroundEffects(dt);

  requestAnimationFrame(loop);
}

// 如果沒有圖片 onload 被觸發（例如快取），仍然啟動
startIfNeeded();

</script>
</body>
</html>

